<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>bcv: basic computer vision</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1><a href="http://vasiliykarasev.github.io/bcv/">bcv</a></h1>
        <p>basic computer vision</p>

        <p class="view"><a href="https://github.com/vasiliykarasev/bcv">view the project on github</a></p>


        <ul>
          <li><a href="https://github.com/vasiliykarasev/bcv/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/vasiliykarasev/bcv/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/vasiliykarasev/bcv">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
<h2>test_tvsegment</h2>

<p>This example is about (multi-label) image segmentation, specifically about a convex relaxation of the Potts model. The problem to find a set of regions <code>R_1</code>, ..., <code>R_K</code> which form a partition of the image domain. This can be formulated as:</p>

<p><img class="eqn" src="website-images/tvsegment0.png" alt="tvsegment eqn"/></p>

<p>The first term penalizes the boundary length. The second term is some prior on region assignments.</p>

<p>A common convex relaxation of this problem is:</p>

<p><img class="eqn" src="website-images/tvsegment1.png" alt="tvsegment eqn"/></p>

<p>where <code>u_1</code>,...,<code>u_K</code> are indicators of a particular region, which can be recovered as <code>R_i = {x: u_i(x) = 1}</code>. The first term is the weighted TV regularization (relaxation of boundary perimeters). The probability simplex constraint is the relaxation of the requirement that only one region must be "active" at a pixel.</p>

<p><strong>Unary term</strong>: In the examples below, the unary term is the Euclidean distance between the image intensity at a pixel and a prototype image intensity <code>c_l</code> (obtained by kmeans)</p>

<p><img class="eqn" src="website-images/tvsegment3.png" alt="tvsegment unary"/></p>

<p>In practice one should use something more sophisticated, e.g. using local statistics.</p>

<p><strong>TV weighing</strong>: The edges are weighed by image similarity as follows:</p>

<p><img class="eqn" src="website-images/tvsegment2.png" alt="tvsegment weights"/></p>

<p>This is customary. The parameter <code>beta</code> can be used to control weights' range. Also, as customary <code>beta</code> is pre-multiplied by the average intensity difference estimated over the entire image.</p>

<p><strong>Optimization</strong>: The problem is solved using first-order primal-dual algorithm (see references). It is highly parallelizable, but the current implementation does not attempt to do that.</p>

<h3>Examples</h3>

<p>A sample call:</p>

<pre><code>./test_tvsegment --input=../images/valley.jpg --output=out.png -beta=20 -lambda=.1 -num_clusters=5
</code></pre>

<p>Output:</p>

<pre><code>kmeans: n pts: 307200, dim: 3, K: 5
learned cluster centers:
K = 0: 0.920650 0.967045 0.994683 
K = 1: 0.295402 0.233376 0.184025 
K = 2: 0.339771 0.576018 0.847665 
K = 3: 0.604728 0.763595 0.941981 
K = 4: 0.460750 0.397112 0.335889 
lambda: 0.100000
beta: 20.000000
num-clusters: 5
isotropic: 1
max-iters: 100
image size: 480x640x3
TV segmentation took: 5325.771973 ms
Wrote the result to 'out.png'
</code></pre>

<p>Below are results for segmentation with varying number of clusters, and varying TV regularization penalty.
<figure>
<a href="website-images/tvsegment_variedK.jpg">
<img src="website-images/tvsegment_variedK.jpg" alt="tv segmentation, varied number of clusters"/>
</a>
<figcaption>Segmentation with varying number of clusters. Left: input image. Right: segmentation with <code>K = 5, 10, 20</code></figcaption>
</figure></p>

<p><figure>
<a href="website-images/tvsegment_variedlambda.jpg">
<img src="website-images/tvsegment_variedlambda.jpg" alt="tv segmentation, varied TV regularization"/>
</a>
<figcaption>Segmentation with 3 clusters and varying TV regularization.. Left: input image. Right: segmentation with <code>lambda = 0.01, 0.1, 0.5</code>. Note that as <code>lambda -&gt; 0</code>, segmentation becomes essentially k-means clustering on the image intensities.</figcaption>
</figure></p>

<p><figure>
<a href="website-images/tvsegment_ex3.jpg">
<img src="website-images/tvsegment_ex3.jpg" alt="tv segmentation"/>
</a>
<figcaption>Top: original image. Bottom: segmentation with <code>K=5</code></figcaption>
</figure></p>

<h3>References</h3>

<ul>
<li><p>Antonin Chambolle, Thomas Pock, "A first-order primal-dual algorithm for convex problems with applications to imaging", Journal of Mathematical Imaging and Vision, 2011.</p></li>
<li><p>Thomas Pock, Antonin Chambolle, Daniel Cremers, Horst Bischof, "A convex relaxation approach for computing minimal partitions", CVPR 2009.</p></li>
</ul>
      </section>
      <footer>
        <p>This project is maintained by <a href="https://github.com/vasiliykarasev">vasiliykarasev</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-60494691-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>
  </body>
</html>